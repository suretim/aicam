// main.c (ESP-IDF project single-file illustrative)
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "esp_system.h"
#include "nvs_flash.h"
#include "nvs.h"
#include <stdlib.h>   
#include <string>
#include <sstream>
#include "esp_log.h"
#include <esp_task_wdt.h>
  
static const char *TAG = "MAIN_LLL";

// Include model_data.h produced by xxd -i student_encoder_fp32.tflite > model_data.h
//#include "model_data.h"

// Optionally include compiled classifier header generated by Python script
//#include "classifier_weights.h" // contains classifier_weights_data and classifier_weights_shape etc
 

// Config -- set to match exported classifier
#define FEATURE_DIM  64   // replace with actual feature_dim from export
#define NUM_CLASSES  5    // replace with actual num_classes from export

// If you included classifier_weights.h, we will use those as initial values
static float classifier_weights[FEATURE_DIM * NUM_CLASSES]; // row-major: weight[f * NUM_CLASSES + c]
static float classifier_bias[NUM_CLASSES];
 

// Initialize classifier arrays from compile-time data (if present)
void init_classifier_from_header() {
    // classifier_weights_data and classifier_bias_data are in classifier_weights.h
#ifdef classifier_weights_data
    // The header contains shapes; but we just copy flatten array
    // NOTE: header written classifier_weights_data in shape [feature_dim][num_classes]
    // We need to copy into our flat buffer in row-major
    int header_len = classifier_weights_len; // produced by header generator
    if (header_len >= FEATURE_DIM * NUM_CLASSES) {
        for (int i = 0; i < FEATURE_DIM * NUM_CLASSES; i++) {
            classifier_weights[i] = classifier_weights_data[i];
        }
    }
    // bias
    for (int j = 0; j < NUM_CLASSES; j++) {
        classifier_bias[j] = classifier_bias_data[j];
    }
#else
    // no header: zero-init
    memset(classifier_weights, 0, sizeof(classifier_weights));
    memset(classifier_bias, 0, sizeof(classifier_bias));
#endif
}

// Dense forward: logits = bias + features @ weights
// features: float features[FEATURE_DIM]
// logits_out: float logits[NUM_CLASSES]
void dense_forward(const float* features, float* logits_out) {
    for (int c = 0; c < NUM_CLASSES; c++) {
        float s = classifier_bias[c];
        for (int f = 0; f < FEATURE_DIM; f++) {
            s += features[f] * classifier_weights[f * NUM_CLASSES + c];
        }
        logits_out[c] = s;
    }
}

// softmax (inplace or output)
void softmax(const float* logits, float* probs_out) {
    float maxv = logits[0];
    for (int i = 1; i < NUM_CLASSES; i++) if (logits[i] > maxv) maxv = logits[i];
    float sum = 0.0f;
    for (int i = 0; i < NUM_CLASSES; i++) {
        probs_out[i] = expf(logits[i] - maxv);
        sum += probs_out[i];
    }
    for (int i = 0; i < NUM_CLASSES; i++) probs_out[i] /= sum;
}
 
 

void initialize_nvs_robust() {
    ESP_LOGI(TAG, "Initializing NVS with robust error handling...");
    
    // 首先尝试正常初始化
    esp_err_t err = nvs_flash_init();
    
    // 处理常见的 NVS 错误
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_LOGW(TAG, "NVS partition corrupted, erasing...");
        
        // 完全擦除 NVS 分区
        ESP_ERROR_CHECK(nvs_flash_erase());
        
        // 重新初始化
        err = nvs_flash_init();
    }
    
    // 如果还有其他错误
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "NVS initialization failed: %s", esp_err_to_name(err));
        ESP_LOGE(TAG, "This is a critical error, restarting...");
        
        // 等待一段时间让日志输出
        vTaskDelay(pdMS_TO_TICKS(1000));
        esp_restart();
    }
    
    ESP_LOGI(TAG, "NVS initialized successfully");
}
 
// Example: update classifier weights from downloaded binary buffer
// Binary layout expected: weights (float32 raw) length FEATURE_DIM * NUM_CLASSES, then bias length NUM_CLASSES
// data: pointer to bytes, len: number of bytes
int update_classifier_from_bin(const uint8_t* data, size_t len) {
    size_t expected = (size_t)(FEATURE_DIM * NUM_CLASSES + NUM_CLASSES) * sizeof(float);
    if (len < expected) {
        printf("update_classifier_from_bin: insufficient data len=%u expected=%u\n", (unsigned)len, (unsigned)expected);
        return -1;
    }
    // copy
    const float* fptr = (const float*)data;
    memcpy(classifier_weights, fptr, FEATURE_DIM * NUM_CLASSES * sizeof(float));
    memcpy(classifier_bias, fptr + FEATURE_DIM * NUM_CLASSES, NUM_CLASSES * sizeof(float));

    // Persist to NVS for reload after reboot
    nvs_handle_t h;
    esp_err_t err = nvs_open("model", NVS_READWRITE, &h);
    if (err == ESP_OK) {
        err = nvs_set_blob(h, "clf_bin", data, expected);
        if (err == ESP_OK) nvs_commit(h);
        nvs_close(h);
    } else {
        printf("NVS open error %d\n", err);
    }
    printf("Classifier updated from binary. Persisted to NVS.\n");
    return 0;
}
//esptool.py --port COM5 erase_flash
 // Restore classifier weights from NVS if present - UPDATED API
 
// 安全的命名空间检查函数
bool check_namespace_exists(const char* namespace_name) {
    nvs_iterator_t it = NULL;
    esp_err_t err = nvs_entry_find("nvs", namespace_name, NVS_TYPE_ANY, &it);
    
    bool exists = (err == ESP_OK && it != NULL);
    
    if (it != NULL) {
        nvs_release_iterator(it);
    }
    
    return exists;
}

// 调试函数：列出所有命名空间和键
void debug_nvs_contents() {
    nvs_iterator_t it = NULL;
    esp_err_t err = nvs_entry_find("nvs", NULL, NVS_TYPE_ANY, &it);
    
    if (err != ESP_OK) {
        ESP_LOGI("NVS_DEBUG", "No entries found in NVS");
        return;
    }
    
    ESP_LOGI("NVS_DEBUG", "NVS contents:");
    
    while (err == ESP_OK) {
        nvs_entry_info_t info;
        nvs_entry_info(it, &info);
        
        ESP_LOGI("NVS_DEBUG", "  Namespace: %s, Key: %s, Type: %d", 
                info.namespace_name, info.key, info.type);
        
        err = nvs_entry_next(&it);
    }
    
    nvs_release_iterator(it);
}


void restore_classifier_from_nvs() {
    ESP_LOGI("NVS", "Attempting to restore classifier from NVS...");
    
    nvs_handle_t h;
    esp_err_t err = nvs_open("model", NVS_READONLY, &h);
    
    if (err != ESP_OK) {
        ESP_LOGW("NVS", "nvs_open failed: %s - This is normal on first boot", esp_err_to_name(err));
        return;
    }
    
    // 确保句柄会被关闭
    auto handle_cleanup = [&h]() { nvs_close(h); };
    
    size_t required = 0;
    err = nvs_get_blob(h, "clf_bin", NULL, &required);
    
    if (err != ESP_OK) {
        ESP_LOGW("NVS", "Classifier blob not found: %s", esp_err_to_name(err));
        handle_cleanup();
        return;
    }
    
    if (required == 0) {
        ESP_LOGW("NVS", "Classifier blob exists but size is 0");
        handle_cleanup();
        return;
    }
    
    ESP_LOGI("NVS", "Found classifier blob, size: %d bytes", required);
    
    uint8_t* buf = (uint8_t*) malloc(required);
    if (!buf) {
        ESP_LOGE("NVS", "Memory allocation failed for %d bytes", required);
        handle_cleanup();
        return;
    }
    
    // 确保内存会被释放
    auto buffer_cleanup = [buf]() { free(buf); };
    
    err = nvs_get_blob(h, "clf_bin", buf, &required);
    if (err == ESP_OK) {
        ESP_LOGI("NVS", "Successfully read classifier data");
        update_classifier_from_bin(buf, required);
    } else {
        ESP_LOGE("NVS", "Failed to read blob data: %s", esp_err_to_name(err));
    }
    
    buffer_cleanup();
    handle_cleanup();
    ESP_LOGI("NVS", "Classifier restore process completed");
}
 // Example MQTT callback (pseudo): receives classifier_weights.bin as payload
// In real code wire up esp-mqtt and call this when message arrives
void mqtt_on_message(const uint8_t* payload, size_t payload_len) {
    // payload should be raw float32 bytes as produced by export script
    int rc = update_classifier_from_bin(payload, payload_len);
    if (rc == 0) {
        printf("MQTT classifier update applied.\n");
    } else {
        printf("MQTT classifier update failed.\n");
    }
}

 

void initialize_nvs() {
    ESP_LOGI(TAG, "Initializing NVS...");
    
    // 尝试初始化 NVS
    esp_err_t err = nvs_flash_init();
    
    // 如果 NVS 分区损坏
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_LOGW(TAG, "NVS partition corrupted, erasing and recreating...");
        
        // 完全擦除 NVS 分区
        ESP_ERROR_CHECK(nvs_flash_erase());
        
        // 重新初始化
        err = nvs_flash_init();
    }
    
    // 检查最终结果
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "NVS initialization failed: %s", esp_err_to_name(err));
        ESP_LOGE(TAG, "Restarting in 5 seconds...");
        vTaskDelay(pdMS_TO_TICKS(5000));
        esp_restart();
    }
    
    ESP_LOGI(TAG, "NVS initialized successfully");
}
 
// 全局异常保护
void safe_nvs_operation() {
    // 设置看门狗
    UBaseType_t stack_watermark = uxTaskGetStackHighWaterMark(NULL);
    ESP_LOGI("SAFE", "Stack watermark: %d", stack_watermark);
    
    // 检查内存
    size_t free_heap = esp_get_free_heap_size();
    ESP_LOGI("SAFE", "Free heap: %d bytes", free_heap);
    
    if (free_heap < 10240) { // 少于 10KB
        ESP_LOGE("SAFE", "Critical: Low memory, skipping NVS operations");
        return;
    }
    
    // 执行安全的 NVS 操作
    restore_classifier_from_nvs();
}
extern void lll_tensor_run();
// Example main demonstrating flow
extern "C" void app_main(void) {
 
 
 //initialize_nvs();
  
initialize_nvs_robust();

    // initialize classifier default from header if compiled in
    init_classifier_from_header();

    // restore persisted classifier if any
    //restore_classifier_from_nvs();
    safe_nvs_operation() ;
    // init tflite
    lll_tensor_run();

    // Now in your app loop you would:
    // - capture image, preprocess to float array matching TFLite input
    // - call run_encoder(image, features)
    // - call dense_forward(features, logits)
    // - optionally softmax and decide class
    // For demonstration we do nothing more.
    while (1) {
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
}

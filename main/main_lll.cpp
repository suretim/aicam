// main.c (ESP-IDF project single-file illustrative)
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "esp_system.h"
#include "nvs_flash.h"
#include "nvs.h"
#include <stdlib.h>   
#include <string>
#include <sstream>
#include "esp_log.h"
#include <esp_task_wdt.h>
 
static const char *TAG = "MAIN_LLL";

// Include model_data.h produced by xxd -i student_encoder_fp32.tflite > model_data.h
//#include "model_data.h"

// Optionally include compiled classifier header generated by Python script
//#include "classifier_weights.h" // contains classifier_weights_data and classifier_weights_shape etc
 

// Config -- set to match exported classifier
#define FEATURE_DIM  64   // replace with actual feature_dim from export
#define NUM_CLASSES  5    // replace with actual num_classes from export

// If you included classifier_weights.h, we will use those as initial values
static float classifier_weights[FEATURE_DIM * NUM_CLASSES]; // row-major: weight[f * NUM_CLASSES + c]
static float classifier_bias[NUM_CLASSES];
 

// Initialize classifier arrays from compile-time data (if present)
void init_classifier_from_header() {
    // classifier_weights_data and classifier_bias_data are in classifier_weights.h
#ifdef classifier_weights_data
    // The header contains shapes; but we just copy flatten array
    // NOTE: header written classifier_weights_data in shape [feature_dim][num_classes]
    // We need to copy into our flat buffer in row-major
    int header_len = classifier_weights_len; // produced by header generator
    if (header_len >= FEATURE_DIM * NUM_CLASSES) {
        for (int i = 0; i < FEATURE_DIM * NUM_CLASSES; i++) {
            classifier_weights[i] = classifier_weights_data[i];
        }
    }
    // bias
    for (int j = 0; j < NUM_CLASSES; j++) {
        classifier_bias[j] = classifier_bias_data[j];
    }
#else
    // no header: zero-init
    memset(classifier_weights, 0, sizeof(classifier_weights));
    memset(classifier_bias, 0, sizeof(classifier_bias));
#endif
}

// Dense forward: logits = bias + features @ weights
// features: float features[FEATURE_DIM]
// logits_out: float logits[NUM_CLASSES]
void dense_forward(const float* features, float* logits_out) {
    for (int c = 0; c < NUM_CLASSES; c++) {
        float s = classifier_bias[c];
        for (int f = 0; f < FEATURE_DIM; f++) {
            s += features[f] * classifier_weights[f * NUM_CLASSES + c];
        }
        logits_out[c] = s;
    }
}

// softmax (inplace or output)
void softmax(const float* logits, float* probs_out) {
    float maxv = logits[0];
    for (int i = 1; i < NUM_CLASSES; i++) if (logits[i] > maxv) maxv = logits[i];
    float sum = 0.0f;
    for (int i = 0; i < NUM_CLASSES; i++) {
        probs_out[i] = expf(logits[i] - maxv);
        sum += probs_out[i];
    }
    for (int i = 0; i < NUM_CLASSES; i++) probs_out[i] /= sum;
}
  
// Example: update classifier weights from downloaded binary buffer
// Binary layout expected: weights (float32 raw) length FEATURE_DIM * NUM_CLASSES, then bias length NUM_CLASSES
// data: pointer to bytes, len: number of bytes
int update_classifier_from_bin(const uint8_t* data, size_t len) {
    size_t expected = (size_t)(FEATURE_DIM * NUM_CLASSES + NUM_CLASSES) * sizeof(float);
    if (len < expected) {
        printf("update_classifier_from_bin: insufficient data len=%u expected=%u\n", (unsigned)len, (unsigned)expected);
        return -1;
    }
    // copy
    const float* fptr = (const float*)data;
    memcpy(classifier_weights, fptr, FEATURE_DIM * NUM_CLASSES * sizeof(float));
    memcpy(classifier_bias, fptr + FEATURE_DIM * NUM_CLASSES, NUM_CLASSES * sizeof(float));

    // Persist to NVS for reload after reboot
    nvs_handle_t h;
    esp_err_t err = nvs_open("model", NVS_READWRITE, &h);
    if (err == ESP_OK) {
        err = nvs_set_blob(h, "clf_bin", data, expected);
        if (err == ESP_OK) nvs_commit(h);
        nvs_close(h);
    } else {
        printf("NVS open error %d\n", err);
    }
    printf("Classifier updated from binary. Persisted to NVS.\n");
    return 0;
}

// Restore classifier weights from NVS if present
void restore_classifier_from_nvs() {
    nvs_handle_t h;
    esp_err_t err = nvs_open("model", NVS_READONLY, &h);
    if (err != ESP_OK) {
        printf("NVS open read err %d\n", err);
        return;
    }
    size_t required = 0;
    err = nvs_get_blob(h, "clf_bin", NULL, &required);
    if (err != ESP_OK || required == 0) {
        printf("No classifier in NVS\n");
        nvs_close(h);
        return;
    }
    uint8_t* buf =(uint8_t*) malloc(required);
    if (!buf) { nvs_close(h); return; }
    err = nvs_get_blob(h, "clf_bin", buf, &required);
    if (err == ESP_OK) {
        update_classifier_from_bin(buf, required); // this will persist again but OK
    }
    free(buf);
    nvs_close(h);
}

// Example MQTT callback (pseudo): receives classifier_weights.bin as payload
// In real code wire up esp-mqtt and call this when message arrives
void mqtt_on_message(const uint8_t* payload, size_t payload_len) {
    // payload should be raw float32 bytes as produced by export script
    int rc = update_classifier_from_bin(payload, payload_len);
    if (rc == 0) {
        printf("MQTT classifier update applied.\n");
    } else {
        printf("MQTT classifier update failed.\n");
    }
}
extern void lll_tensor_run();
// Example main demonstrating flow
extern "C" void app_main(void) {
 
 


// First try standard initialization
esp_err_t ret = nvs_flash_init();

// Handle common initialization errors
if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    // NVS needs to be erased
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
}
ESP_ERROR_CHECK(ret);

// For persistent error 4354, add deeper recovery:
if (ret == 4354) {  // Or use ESP_ERR_NVS_xxx equivalent
    printf("NVS Corruption Detected. Performing deep recovery...\n");
    nvs_flash_deinit();
    const esp_partition_t* nvs_partition = esp_partition_find_first(
        ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_NVS, NULL);
    if (nvs_partition) {
        esp_partition_erase_range(nvs_partition, 0, nvs_partition->size);
    }
    ret = nvs_flash_init();
}





    // initialize classifier default from header if compiled in
    init_classifier_from_header();

    // restore persisted classifier if any
    restore_classifier_from_nvs();

    // init tflite
    lll_tensor_run();

    // Now in your app loop you would:
    // - capture image, preprocess to float array matching TFLite input
    // - call run_encoder(image, features)
    // - call dense_forward(features, logits)
    // - optionally softmax and decide class
    // For demonstration we do nothing more.
    while (1) {
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
}
